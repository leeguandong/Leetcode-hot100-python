做题思路：

1.直接看题解
2.本地快速实现
3.写一遍


106版本：
先过一遍，整体过一遍，不细看


1017版本：
总结规律
两数之和：dict
字母异位词分组：defaultdict(list)
最长连续序列：set 主要是o(1)

移动零：和双指针无关，非零的前移，剩下来的都是0
三数之和：while->left/right

找到字符串中所有字母异位词：滑动窗口内的计数相同，则异位
无重复字符的最长子串：set做一个小窗口

和为k的子数组：累加的数减去k只要能等于之前的累计和，一定存在这么一个数，从这个数到目前的节点和等于k

合并区间：sort、for、区间边缘值对比，ans中的-1、1和p对比
最大子数组和：for，维护一个min，算差值

搜索二维矩阵II：矩阵从左到右升序，从上到下升序，j是列，i是行，i往下走，j往左走
旋转图像：两层循环，i/j,右下角往左上角移动，以此循环
矩阵置零：找到等于0的，先把行置零，在循环零的行，把列置零

反转链表：while,tmp,然后把cur的下一个节点给到None，在cur和pre同步往前走
合并两个有序链表：递归，一个val小于另一个val，就递归
回文链表：找个[]存下来所有的数在判断
环形链表：快慢指针，当快指针遇到慢指针的时候
相交链表：while，A往后跑，跑完等于B，反之一样
两两交换链表中的节点：2到0,2到1,1到3，while
两数相加：while l1 or l2，持续l1.val+l2.val,一直加
删除链表的倒数第N个节点：快节点跑N，慢节点再走，快慢节点相差N，则快节点到终点，慢节点则是倒数第N
环形链接II：慢节点和head节点一起走，慢节点等于head节点，换节点
随机链表的复制：dict存一个node，先把node关系绑定，再把next和random绑上

二叉树的中序遍历：判定条件+递归
二叉树的最大深度：递归，max
二叉树的直径：dfs,left+right节点
对称二叉树：dfs,left.val==right.val
将有序数组组成平衡二叉搜索树：dfs,start/end,中间拉起来，两边递归成树
翻转二叉树：递归，left和right互换
二叉搜索树种的第k小的元素：二叉搜索树中序遍历为递归的，dfs中对k-=1
二叉树展开为链表：ans=[],dfs之后存下来，while ans，left=None,right=ans.pop(0)
二叉树的右视图：dfs，depth == len(ans),前序遍历
二叉树的层序遍历：while，每次都把一个节点的值存储起来再循环
二叉树的最近公共祖先：递归，有谁在就返回谁
从前序与中序遍历序列构造二叉树：前序：根左右，中序：左根右；找到根之后递归左右
验证二叉搜索树：left<x<right

全排列：三部曲 n/path/ans + dfs,唯一一个不需要还原，set
分割回文串：三部曲+dfs,t=s[i:j+1],
单词搜索：dfs，board和word是否相等，上下左右四个方向测一下
子集：三部曲+dfs，选/不选
括号生成：三部曲，n,m=2*n,dfs,
电话号码的字母组合：三部曲
组合总结：三部曲，选/不选

整数插入位置：while，找到中间节点，然后中间节点和target比来移动左右节点
在排序数组中查找元素的第一个和最后一个位置：get_index去找目标的位置，选起始点
寻找旋转排序数组中的最小值：核心就是二分之后，当前值比最右边大，那么最小值就在右边

有效的括号：dict，[],在dict中就放到栈里，不在的话，就从栈里往外弹出来，不等于当前字符的话，就有问题
字符串解码：栈[],res=""具体的字母，multi记录数字，要转换的，[存入，]转出，0-9之间要转换
每日温度：三部曲，只要栈最上面的值比当前值小，一直弹出，

前k个高频元素：
数组中的第k个最大元素：排序（升序），在取到一半以上的

买卖股票的最佳时机：一个max，一个min
划分字母区间：temp表示该字母出现的最大次数最后一个位置，start,end,等达到end时，end-start+1
跳跃游戏：i比mx大，一定达到不了最后一位

杨辉三角：dp数组，递归，左上+上
爬楼梯：dfs(i)+dfs(i-2)
乘积最大子数组：pre_max_num/pre_min_num，循环，max/min,min是用来处理负数的
分割等和子集：dfs(i-1,s-nums[i]) or dfs(i-1,s),肯定都要-1，没选到就不减
单词拆分：dfs,for s[i:j] in worddict and dfs(j)
完全平方数：dfs,min(dfs(i,n-i*i)+1,dfs(i-1,n))
打家劫舍：dfs,max(dfs(i-2)+nums[i],dfs(i-1))
最长递归子序列：if nums[j]<nums[i]:res=max(res,dfs(j))
零钱兑换：dfs,min(dfs(i,j-coins[i])+1,dfs(i-1,j))

不同路径：dp[i][j] = dp[i-1][j]+dp[i][j-1]
最小路径和：要考虑i/j的不同情况，dp[i][j] = min(dp[i-1][j],dp[i][j-1])+grid[i][j]
最长公共子序列：相等，dfs(i-1,j-1)+1,不相等，max(dfs(i-1,j),dfs(i,j-1))
编译距离：相等，dfs(i-1,j-1),不相等，min(dfs(i-1,j),dfs(i,j-1),dfs(i-1,j-1))+1

多数元素：nums.sort()



















